Swift async algorithms is a package of algorithms focused on processing values over time. It extends AsyncSequence by incorporating more advanced algorithms, as well as interoperating with clocks augment Swift concurrency. The package augments Swift concurrency. An example is using asynchronous Zip to take multiple inputs and iterating to produce a tuple of each others' bases. It does so concurrently and re-throws errors if a failure occurs on any iteration. For a video messaging app example, this more easily allows transcoding and generating previews without delaying each other. 

The Swift Async Algorithms package brings in a family of algorithms to work with time by leveraging the new Clock API in Swift. The ContinuousClock is used to measure time just like a stopwatch, where time progresses no matter the state of the thing being measured. The SuspendingClock suspends when the machine is put to sleep. The async algorithm package uses the clock API to migrate from existing callback events to clock sleep function to handle dismissing alerts after a deadline. You create the deadline by adding a duration value that indicates specifically the number of seconds we want to delay.
 The key difference between these two clocks comes from its behavior when the machine is asleep.
For long running work like these, the work can be paused but when we resume the execution, the ContinuousClock has progressed while the machine was asleep, but the SuspendingClock did not.
 Commonly, this difference can be the key detail to make sure things like animations work as expected by suspending the timing of the execution. If you need to interact with time in relation to the machine, like for animations, use the SuspendingClock. If you need to delay by an absolute duration, something relative to humans, use the ContinuousClock.

In the Swift algorithms package, there's a set of algorithms to chunk values. The Swift Async Algorithms package offers those, but also adds a set of versions that interoperate with clocks and durations. The family of chunking algorithms allow for control over chunks by count, by time, or by content. If an error occurs in any of these, that error is re-thrown, so our code is safe when it comes to failures. Use of the "chunked(by:)" API to ensure that chunks of messages are serialized and sent off by a certain elapsed duration.

AsyncSequence works much like how the lazy algorithms work in the Swift standard library. Just like those lazy algorithms, there are times where you need to move back into the world of collections. The Swift Async Algorithms package offers a set of initializers for constructing collections using AsyncSequence. These let you build up dictionaries, sets, or arrays with input AsyncSequences that are known to be finite. the collection initializers let us build in conversions right into our initialization of messages and keep our data types as Array.